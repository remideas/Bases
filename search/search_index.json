{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Bases it's a Roblox Studio module made by remi that allows you to sandbox with custom instance classes to do any crazy ideas you can imagine, no metatables needed, just a table in a module script. I'm trying to improve sandboxing and performance the best I can, if you have any suggestions/ideas feel free to tell me about them. If you find any bug I would be very happy that you report it to me. Here's the GitHub repository . It's very simple! Bases allow you to create custom instance classes without any effort, even a banana can do it! It's just a few lines of code to start working on amazing projects. We will guide you through in this documents to solve any question you have! Why Bases? You may be asking why you should use Bases over the conventional OOP method? Well, Bases it's created around the idea of creating custom instance classes. This means that you can simulate the behavior of a normal Roblox's instance and create your own instance type, for example, a Roblox's instance of the class BasePart looks like this: And an instance created from the next Bases' class looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local bases = require ( script . Parent ) local bouncy_part = bases ( \"setup\" , script ) local methods = bouncy_part . methods bouncy_part . instance_name = \"BouncyPart\" bouncy_part . add_attribute ( \"public\" , \"BounceForce\" , 25 ) function methods : Bounce () self : ApplyImpulse ( Vector3 . new ( 0 , self . BounceForce , 0 ) * self : GetMass () * 3 ) end return bouncy_part So basically, Bases allows you to wrap instance classes to create your own instance class with custom attributes and methods, being able to interact with your object within the real instance. To achieve this with the conventional OOP method, you just need to modify your metamethods and class but it will not look like a Roblox's instance class to the user; so I made it for you! Warning You shouldn't use Bases to create non-instance classes since you will be wasting memory. Extras Bases bring two friends to the party, even if you don't know their names you will like to use them! Bases include two additional modules added into its source code which you can access from any script if wanted. Those modules were originally only going to be available for the master module, but why not let users use them? So you are free to check them out. There's no need for adding those separately, they come together!","title":"Introduction"},{"location":"#introduction","text":"Bases it's a Roblox Studio module made by remi that allows you to sandbox with custom instance classes to do any crazy ideas you can imagine, no metatables needed, just a table in a module script. I'm trying to improve sandboxing and performance the best I can, if you have any suggestions/ideas feel free to tell me about them. If you find any bug I would be very happy that you report it to me. Here's the GitHub repository .","title":"Introduction"},{"location":"#its-very-simple","text":"Bases allow you to create custom instance classes without any effort, even a banana can do it! It's just a few lines of code to start working on amazing projects. We will guide you through in this documents to solve any question you have!","title":"It's very simple!"},{"location":"#why-bases","text":"You may be asking why you should use Bases over the conventional OOP method? Well, Bases it's created around the idea of creating custom instance classes. This means that you can simulate the behavior of a normal Roblox's instance and create your own instance type, for example, a Roblox's instance of the class BasePart looks like this: And an instance created from the next Bases' class looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local bases = require ( script . Parent ) local bouncy_part = bases ( \"setup\" , script ) local methods = bouncy_part . methods bouncy_part . instance_name = \"BouncyPart\" bouncy_part . add_attribute ( \"public\" , \"BounceForce\" , 25 ) function methods : Bounce () self : ApplyImpulse ( Vector3 . new ( 0 , self . BounceForce , 0 ) * self : GetMass () * 3 ) end return bouncy_part So basically, Bases allows you to wrap instance classes to create your own instance class with custom attributes and methods, being able to interact with your object within the real instance. To achieve this with the conventional OOP method, you just need to modify your metamethods and class but it will not look like a Roblox's instance class to the user; so I made it for you! Warning You shouldn't use Bases to create non-instance classes since you will be wasting memory.","title":"Why Bases?"},{"location":"#extras","text":"Bases bring two friends to the party, even if you don't know their names you will like to use them! Bases include two additional modules added into its source code which you can access from any script if wanted. Those modules were originally only going to be available for the master module, but why not let users use them? So you are free to check them out. There's no need for adding those separately, they come together!","title":"Extras"},{"location":"getting_started/","text":"Getting Started Let's get started, get the module via toobolx or copy the code into a module from github . Configuring the module Set the parent of the module, I prefer ReplicatedStorage, open the module, and scroll down until you reach Settings now the only two things you need to focus on right now are: local debug_enabled = true -- Print the recognized classes after loading them. local silence_module = \"__\" -- Keyword to silence modules. I think the comments are self-explanatory, but I will explain you anyways; debug_enabled is a variable that will determine whether or not to print the recognized classes after loading them. graph LR; A[Script] -->|require| B[Module]; B --> C[Load Classes]; C --> |Silenced|D[Ignore]; C --> |Not Silenced| E[Load]; E --> F[Error?]; F --> |yes| D; F --> |no| G[Print]; It will look like this If the value is set to false, the message will stop printing in the output, if a class was not loaded, means that its either silenced or it raises an error. The silence_module variable it's the prename you will need to set to a module's name to silence it. Adding classes To add a class to Bases module, all you need to do is create a ModuleScript inside it; the name of it must be the name you want to assign to your class. Example: Silencing modules Silencing a module means ignoring it when loading the classes in the master module, you may noticed that Bases module includes a children, which is an example class to introduce the user.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"Let's get started, get the module via toobolx or copy the code into a module from github .","title":"Getting Started"},{"location":"getting_started/#configuring-the-module","text":"Set the parent of the module, I prefer ReplicatedStorage, open the module, and scroll down until you reach Settings now the only two things you need to focus on right now are: local debug_enabled = true -- Print the recognized classes after loading them. local silence_module = \"__\" -- Keyword to silence modules. I think the comments are self-explanatory, but I will explain you anyways; debug_enabled is a variable that will determine whether or not to print the recognized classes after loading them. graph LR; A[Script] -->|require| B[Module]; B --> C[Load Classes]; C --> |Silenced|D[Ignore]; C --> |Not Silenced| E[Load]; E --> F[Error?]; F --> |yes| D; F --> |no| G[Print]; It will look like this If the value is set to false, the message will stop printing in the output, if a class was not loaded, means that its either silenced or it raises an error. The silence_module variable it's the prename you will need to set to a module's name to silence it.","title":"Configuring the module"},{"location":"getting_started/#adding-classes","text":"To add a class to Bases module, all you need to do is create a ModuleScript inside it; the name of it must be the name you want to assign to your class. Example:","title":"Adding classes"},{"location":"getting_started/#silencing-modules","text":"Silencing a module means ignoring it when loading the classes in the master module, you may noticed that Bases module includes a children, which is an example class to introduce the user.","title":"Silencing modules"}]}